// Generated by CoffeeScript 1.4.0
var ArgumentParser, NS, arg, args, argv, assert, data, failures, file_texts, filename, fs, ns, oldcwd, os, parser, path, psplit, setup_tempdir, successes, teardown_tempdir, tpl, _, _i, _j, _k, _len, _len1, _len2;

fs = require('fs');
os = require('os');
path = require('path');
assert = require('assert');
_ = require('underscore');
_.str = require('underscore.string');

ArgumentParser = require('../lib/argparse').ArgumentParser;

psplit = function(argv) {
  // split string into argv array, removing empty strings  
  var a, _i, _len, _ref, _results;
  _ref = argv.split(' ');
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    a = _ref[_i];
    if (a != null) {
      _results.push(a);
    }
  }
  return _results;
};

NS = function(args) {
  // simplified namespace object
  return args;
};

file_texts = [['hello', 'hello world!\n'], 
              ['recursive', '-a\n', 'A\n', '@hello'], 
              ['invalid', '@no-such-path\n']];

setup_tempdir = function() {
  // setup a temporary directory as cwd  
  var oldcwd, tdir;
  tdir = path.join(os.tmpDir(), 'argparse_temp');
  try {
    fs.mkdirSync(tdir);
  } catch (error) {
    if (!error.message.match(/EEXIST/)) {
      throw error;
    }
  }
  oldcwd = process.cwd();
  process.chdir(tdir);
  console.log('Now in ' + process.cwd());
  return oldcwd;
};

teardown_tempdir = function(oldcwd) {
  // remove the temp dir
  var f, tdir, _i, _len, _ref;
  tdir = process.cwd();
  process.chdir(oldcwd);
  if (_.str.startsWith(tdir, os.tmpDir())) {
    _ref = fs.readdirSync(tdir);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      fs.unlinkSync(path.join(tdir, f));
    }
    fs.rmdir(tdir);
    return console.log('Removed ' + tdir);
  }
};

oldcwd = setup_tempdir();

// write the test files
for (_i = 0, _len = file_texts.length; _i < _len; _i++) {
  tpl = file_texts[_i];
  filename = tpl[0];
  data = tpl.slice(1).join('');
  fs.writeFileSync(filename, data);
}

// parser with the fromfilePrefixChars
parser = new ArgumentParser({debug: true, fromfilePrefixChars: '@'});

parser.addArgument(['-a']);
parser.addArgument(['x']);
parser.addArgument(['y'], {nargs: '+'});

console.log(parser.formatHelp());

console.log(parser.parseArgs(['X', 'Y']));

failures = ['', '-b', 'X', '@invalid', '@missing'];

successes = [
  ['X Y', NS({a: null, x: 'X', y: ['Y']})], 
  ['X -a A Y Z', NS({ a: 'A',  x: 'X',  y: ['Y', 'Z'] })], 
  ['@hello X', NS({a: null, x: 'hello world!', y: ['X']})], 
  ['X @hello', NS({a: null, x: 'X', y: ['hello world!']})], 
  ['-a B @recursive Y Z', NS({a: 'A', x: 'hello world!', y: ['Y', 'Z']})], 
  ['X @recursive Z -a B', NS({a: 'B', x: 'X', y: ['hello world!', 'Z']})]
];

for (_j = 0, _len1 = failures.length; _j < _len1; _j++) {
  argv = failures[_j];
  try {
    args = parser.parseArgs(psplit(argv));
    console.log("TODO, expected error for '" + argv + "'");
    console.log(args);
  } catch (error) {
    console.log(_.str.strip(error.message));
    console.log("error as expected for '" + argv + "'");
  }
  console.log('');
}

for (_k = 0, _len2 = successes.length; _k < _len2; _k++) {
  arg = successes[_k];
  argv = arg[0], ns = arg[1];
  console.log(argv, '=>', ns);
  try {
    args = parser.parseArgs(psplit(argv));
    assert.deepEqual(args, ns);
  } catch (error) {
    console.log('TODO', error);
  }
  console.log('');
}

teardown_tempdir(oldcwd);

/*
another test creates new ArgumentParser class, one with a custom
convert_arg_line_to_args() function

    class FromFileConverterArgumentParser(ErrorRaisingArgumentParser):

        def convert_arg_line_to_args(self, arg_line):
            for arg in arg_line.split():
                if not arg.strip():
                    continue
                yield arg
    parser_class = FromFileConverterArgumentParser
*/

